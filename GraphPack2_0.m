(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*<<PhysicalConstants`
Gm=GravitationalConstant*(( Meter^2 Newton)/Kilogram^2)^-1;
\[Sigma]s=StefanConstant/(Watt/(Kelvin^4 Meter^2));
AUs=Convert[1*AU,Meter]/Meter;
days=3600*24;
years=31557600;
Msun=1.9891*^30;
Rsun=6.96*^8;
Lsun=3.839*^26;
Rjup=7.1492*^7;
Mmoon=7.34*^22;
Mearth=5.97*^24;
Moceans=1.41*^21;
Rearth=6.371*^6;
Mjup=1.8986112*^27;
Rsat=6.0268*^7;
Msat=5.6846*^26;
bar=1*^5;*)


(*nnn[a_,M_,m_]:=Sqrt[(Gm(M+m))/a^3];*)


(*<<PhysicalConstants`
clum=SpeedOfLight*Second/Meter;
hplanck=PlanckConstant/Joule/Second;
kboltz=BoltzmannConstant/Joule*Kelvin;
Ang=10^-10;
mH=1.672621637`*^-27;
me=9.10938215`*^-31;
e=1.602176487`*^-19;
Rgp=8.3144621;
parsec=3.08567758*^16;*)


Readnc1D[Name_]:=Module[{raw,time,cont,tsurf,ASR,OLR,temp,teta,aps,bps,pp,ap,bp,plev,dP,psurf,grav,mugaz,dz,zz,rho},
raw=Import[Name,"NetCDF"];
time=If[MemberQ[raw,"Time"],Import[Name,{"Datasets", "Time"}],{0}];
cont=If[MemberQ[raw,"controle"],Import[Name,{"Datasets", "controle"}],{0}];
grav=cont[[7]];mugaz=cont[[8]]*1*^-3;
tsurf=If[MemberQ[raw,"tsurf"],Flatten[Import[Name,{"Datasets", "tsurf"}]],{0}];
ASR=If[MemberQ[raw,"ASR"],Flatten[Import[Name,{"Datasets", "ASR"}]],{0}];
OLR=If[MemberQ[raw,"OLR"],Flatten[Import[Name,{"Datasets", "OLR"}]],{0}];
psurf=If[MemberQ[raw,"p"],Flatten[Import[Name,{"Datasets", "p"}]][[1]],{0}];
aps=If[MemberQ[raw,"aps"],Import[Name,{"Datasets", "aps"}],{0}];
bps=If[MemberQ[raw,"bps"],Import[Name,{"Datasets", "bps"}],{0}];
pp=psurf*bps+aps;
ap=If[MemberQ[raw,"ap"],Import[Name,{"Datasets", "ap"}],{0}];
bp=If[MemberQ[raw,"bp"],Import[Name,{"Datasets", "bp"}],{0}];
plev=psurf*bp+ap;
temp=If[MemberQ[raw,"temp"],Map[Flatten,Import[Name,{"Datasets", "temp"}]],{0}];
rho=mugaz/( Rgp temp[[1]]) pp;
dz=Map[Flatten[Table[Rgp/(grav mugaz) #[[ii]]{(plev[[ii]]-pp[[ii]])/Sqrt[plev[[ii]]pp[[ii]]],(pp[[ii]]-plev[[ii+1]])/Sqrt[pp[[ii]]*Max[plev[[ii+1]],0.1]]},{ii,Length[pp]}]]&,temp];
zz=Map[Accumulate,dz];
zz=zz[[All,2*Range[Length[pp]]-1]]/1000;
teta=If[MemberQ[raw,"teta"],Map[Flatten,Import[Name,{"Datasets", "teta"}]],{0}];
{time,zz,pp,temp,teta,tsurf,psurf,ASR,OLR}
]


(* ::Input:: *)
(**)


(*<<PlotLegends`;
<<ErrorBarPlots`;
$Packages;
Needs["PlotLegends`"]\.1c;
Button[Needs, Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Needs"]["ErrorBarPlots`"]\.1c;*)


imageSize=300;
marginsize=2;
gray=0.85;
SetOptions[ListLinePlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
Joined->True,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[Plot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[ParametricPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[LogPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[LogLinearPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[LogLogPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[ListLogPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
Joined->True,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[ListLogLogPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
Joined->True,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[ListLogLinearPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
Joined->True,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[ListPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
PlotStyle->Thick,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
GridLines->Automatic,
GridLinesStyle->Directive[GrayLevel[gray]],
ImageMargins->marginsize];
SetOptions[ListContourPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
ImageMargins->marginsize];
SetOptions[ContourPlot,
Frame->True,
FrameStyle->Medium,
Axes->False,
ImageSize->{imageSize,Automatic},
PreserveImageOptions->Automatic,
Background->White,
ImageMargins->marginsize];


PlotTransitError[dataXY_,errorX_,errorY_,textX_,textY_,Range_:{Automatic,Automatic}]:=Show[ErrorListPlot[Table[{dataXY[[i]],ErrorBar[errorX[[i]],errorY[[i]]]},{i,Length[dataXY]}],PlotRange->Range,
PlotStyle->{AbsoluteThickness[1.],Hue[0.7,1,0.5,0.5]},FrameLabel->{StyleForm[textX,FontSize->13,FontFamily->"Times"],StyleForm[textY,FontSize->13,FontFamily->"Times"]}],
ListPlot[dataXY[[Table[i,{i,Length[dataXY]}]]],PlotMarkers->{Automatic,Small}]];


PlotTransitErrorAndFit[dataXY_,errorX_,errorY_,textX_,textY_,fit_,Range_:{Automatic,Automatic}]:=Show[ErrorListPlot[Table[{dataXY[[i]],ErrorBar[errorX[[i]],errorY[[i]]]},{i,Length[dataXY]}],PlotRange->Range,
PlotStyle->{AbsoluteThickness[1.],Hue[0.7,1,0.5,0.5]},FrameLabel->{StyleForm[textX,FontSize->13,FontFamily->"Times"],StyleForm[textY,FontSize->13,FontFamily->"Times"]}],
ListPlot[dataXY[[Table[i,{i,Length[dataXY]}]]],PlotMarkers->{Automatic,Small}],
Plot[fit[x],{x,Min[dataXY[[All,1]]],Max[dataXY[[All,1]]]}]];


chi2[data_,fit_,dy_:1]:=Sum[(data[[i,2]]-fit[data[[i,1]]])^2/If[Length[dy]==0,dy,dy[[i]]]^2,{i,Length[data]}]
chi2XY[data_,fit_,dx_:1,dy_:1]:=Sum[(data[[i,2]]-fit[data[[i,1]]])^2/(If[Length[dy]==0,dy,dy[[i]]]^2+CoefficientList[fit[x],x][[2]]^2*If[Length[dx]==0,dx,dx[[i]]]^2),{i,Length[data]}]
chi2XYab[data_,a_,b_,dx_:1,dy_:1]:=Sum[(data[[i,2]]-b*data[[i,1]]-a)^2/(If[Length[dy]==1,dy,dy[[i]]]^2+b^2*If[Length[dx]==1,dx,dx[[i]]]^2),{i,Length[data]}]


FindChiMin[data_,errorX_,errorY_]:=Module[{a,b,fit},
Minimize[chi2XY[data,b #+a&,errorX,errorY],{a,b}]]
FindChiMinAconstrained[data_,errorX_,errorY_]:=Module[{a,b,fit},
Minimize[chi2XYab[data,(Sum[(data[[i,2]]-b*data[[i,1]])/(errorX[[i]]^2*b^2+errorY[[i]]^2),{i,Length[data]}]/Sum[1/(errorX[[i]]^2*b^2+errorY[[i]]^2),{i,Length[data]}]),b,errorX,errorY],{b}]]
